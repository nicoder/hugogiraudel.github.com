

<rss version="2.0">
	<channel>
		<title>HugoGiraudel.com</title>
		<link>http://hugogiraudel.com</link>
		<description>I write about Sass.</description>
		<language>en</language>
		<copyright>2014</copyright>
		
			
<item>
	<title>Managing responsive breakpoints in Sass</title>
	
	<link>http://www.sitepoint.com/managing-responsive-breakpoints-sass/</link>
	<guid>http://www.sitepoint.com/managing-responsive-breakpoints-sass/</guid>
	
	
	<pubDate>Sun, 25 May 2014 00:00:00 GMT</pubDate>
	<description>
</description>
</item>

<item>
	<title>A new Sass mixin for offsets</title>
	
	<link>http://hugogiraudel.com/article/2014-05-19-new-offsets-sass-mixin</link>
	<guid>/article/2014-05-19-new-offsets-sass-mixin</guid>
	
	
	<pubDate>Mon, 19 May 2014 00:00:00 GMT</pubDate>
	<description>
&lt;p&gt;About a year ago, I wrote about how I managed to come up with what I think is &lt;a href=&quot;http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/&quot;&gt;a clever Sass mixin to deal with offset positioning&lt;/a&gt; in CSS, also known as &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;The mixin was directly inspired from &lt;a href=&quot;https://github.com/visionmedia/nib&quot;&gt;Nib&lt;/a&gt;, &lt;a href=&quot;http://learnboost.github.io/stylus/&quot;&gt;Stylus&lt;/a&gt;&amp;#8217; most popular framework. The idea is to be able to declare all desired offsets in a single declaration rather than having to write multiple CSS properties. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// Stylus syntax
selector {
  absolute: top 1em right 100%
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When looking back at Nib&amp;#8217;s documentation a couple of weeks ago, I noticed there are a couple of features I missed when implementing the Sass version of this little gem. Hence the brand new version of the mixin, and the blog post explaining the process.&lt;/p&gt;

&lt;p&gt;Unfortunately, Sass in its SCSS syntax doesn&amp;#8217;t provide as much abstraction as Stylus does, so we still have to use some extra characters, especially &lt;code&gt;@include&lt;/code&gt;, parenthesis, colons and semi-colons&amp;#8230; That being said, the result is quite good in my opinion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// SCSS
selector {
  @include absolute(top 1em right 100%)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;What we want? Offsets!&lt;/h2&gt;

&lt;p&gt;Before jumping on the code, it is important to analyze the topic so we can implement things right. There are a few different use cases, but the main idea is always the same: we loop through the 4 offsets to see if they are being passed to our mixin. Then, depending on how it&amp;#8217;s going, various things happen. Let&amp;#8217;s see each case one by one.&lt;/p&gt;

&lt;p&gt;Case 1. &lt;strong&gt;The offset has not been found in the list.&lt;/strong&gt; Obviously, we stop there and do not output it.&lt;/p&gt;

&lt;p&gt;Case 2. &lt;strong&gt;The offset has been found at the last index of list.&lt;/strong&gt; We output it to &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// SCSS
@include absolute(top);

// CSS
position: absolute;
top: 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Case 3. &lt;strong&gt;The offset has been found and the next item is another offset.&lt;/strong&gt; We output it to &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// SCSS
@include absolute(top left);

// CSS
position: absolute;
top: 0;
left: 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Case 4. &lt;strong&gt;The offset has been found and the next item is invalid.&lt;/strong&gt; An invalid value could be a string other than &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; and &lt;code&gt;inherit&lt;/code&gt;, or any value that is not a number, or a unitless number. In any case, we do not output the offset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// SCSS
@include absolute(top &quot;string&quot;);

// CSS
position: absolute;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Case 5. &lt;strong&gt;The offset has been found and the next item is valid.&lt;/strong&gt; Of course then, we output the offset with the next item as a value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// SCSS
@include absolute(top 1em);

// CSS
position: absolute;
top: 1em;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if we sum up:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if offset doesn&amp;#8217;t exist or offset exists but is followed by an invalid value, we don&amp;#8217;t output it&lt;/li&gt;
  &lt;li&gt;if offset exist as last item or offset is followed by another offset, we output it to &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;if offset exist and is followed by valid value, we output it to the value&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Starting with the helper&lt;/h2&gt;

&lt;p&gt;As you may have understood from what we have just seen, we will need to determine if the value directly following the offset is a valid value for an offset property (&lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt; or &lt;code&gt;left&lt;/code&gt;). Nothing better than a little function to do that.&lt;/p&gt;

&lt;p&gt;Should be considered as a valid length:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a number with a unit&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;initial&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;inherit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@function is-valid-length($value) {
  @return (type-of($value) == &quot;number&quot; and not unitless($value)) 
       or (index(auto initial inherit 0, $value) != false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function is as simple as that. First we check if it&amp;#8217;s a number with a unit. If it is not, we check whether it is an allowed value. If it is not again, then it is not a valid length for an offset property. &lt;/p&gt;

&lt;h2&gt;Building the mixin&lt;/h2&gt;

&lt;p&gt;Now that we have our helper function and all our use-cases, it is time to move on to the mixin. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin position($position, $args: ()) {
  $offsets: top right bottom left;
  position: $position;
  
  @each $offset in $offsets {
    // Doing the magic trick
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From there, we iterate through the offsets list (so 4 times) and for each one, we do the checks we discussed in the first section of this article. I added comments to the code so you can follow along but it is pretty straight forward anyway.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// All this code happens inside the loop
$index: index($args, $offset);

// If offset is found in the list
@if $index {

  // If it is found at last position
  @if $index == length($args) {
    #{$offset}: 0;
  }

  // If it is followed by a value
  @else {
    $next: nth($args, $index + 1);

    // If the next value is value length
    @if is-valid-length($next) {
      #{$offset}: $next;
    }

    // If the next value is another offset
    @else if index($offsets, $next) {
      #{$offset}: 0;
    }

    // If it is invalid
    @else {
      @warn &quot;Invalid value `#{$next}` for offset `#{$offset}`.&quot;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then of course, there are still the 3 extra mixins &lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt; and &lt;code&gt;fixed&lt;/code&gt;. This doesn&amp;#8217;t change at all from the previous version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin absolute($args: ()) {
  @include position(absolute, $args);
}
 
@mixin fixed($args: ()) {
  @include position(fixed, $args);
}
 
@mixin relative($args: ()) {
  @include position(relative, $args);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Examples&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.a { 
  @include absolute()
}

.a {
  position: absolute;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.b {
  @include absolute(top)
}

.b {
  position: absolute;
  top: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.c {
  @include absolute(top right)
}

.c {
  position: absolute;
  top: 0;
  right: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.d {
  @include absolute(top right bottom)
}

.d {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.e {
  @include absolute(top right bottom left)
}

.e {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.f {
  @include absolute(top right 1em)
}

.f {
  position: absolute;
  top: 0;
  right: 1em;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.g {
  @include absolute(top 1em right)
}

.g {
  position: absolute;
  top: 1em;
  right: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.h {
  @include absolute(top 1em right 100%)
}

.h {
  position: absolute;
  top: 1em;
  right: 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.i {
  @include absolute(top right mistake)
}

.i {
  position: absolute;
  top: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.j {
  @include absolute(top 1em right 1em bottom 1em left 1em)
}

.j {
  position: absolute;
  top: 1em;
  right: 1em;
  bottom: 1em;
  left: 1em;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;So here we go with the new version guys. It is slightly better than the old since you can now chain offsets to set them to &lt;code&gt;0&lt;/code&gt;, and extra keywords like &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; and &lt;code&gt;inherit&lt;/code&gt; are allowed, which wasn&amp;#8217;t the case before.&lt;/p&gt;

&lt;p&gt;I hope you like it. If you think of anything to improve it, be sure to share!&lt;/p&gt;

&lt;p class=&quot;sassmeister&quot; data-gist-id=&quot;f8ab9cc308b84e37b18d&quot; data-height=&quot;480&quot;&gt;&lt;a href=&quot;http://sassmeister.com/gist/f8ab9cc308b84e37b18d&quot;&gt;Play with this gist on SassMeister.&lt;/a&gt;&lt;/p&gt;
</description>
</item>

<item>
	<title>Supporting multiple versions of Sass</title>
	
	<link>http://webdesign.tutsplus.com/articles/when-and-how-to-support-multiple-versions-of-sass--cms-20935</link>
	<guid>http://webdesign.tutsplus.com/articles/when-and-how-to-support-multiple-versions-of-sass--cms-20935</guid>
	
	
	<pubDate>Tue, 13 May 2014 00:00:00 GMT</pubDate>
	<description>
</description>
</item>

<item>
	<title>Modernizr Sass mixin</title>
	
	<link>http://hugogiraudel.com/article/2014-05-12-modernizr-sass-mixin</link>
	<guid>/article/2014-05-12-modernizr-sass-mixin</guid>
	
	
	<pubDate>Mon, 12 May 2014 00:00:00 GMT</pubDate>
	<description>
&lt;blockquote&gt;
  &lt;p&gt;The following is a guest post by Daniel Guillan. Daniel is the co-founder and chief design officer at Vintisis. I am very glad to have him here today, writing about a clever mixin to ease the use of Modernizr with Sass.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I use &lt;a href=&quot;http://modernizr.com/&quot;&gt;Modernizr&lt;/a&gt; on every single project I work on. In a nutshell, it&amp;#8217;s a JS library that helps us take decisions based on the capabilities of the browser accessing our site. Modernizr quickly performs tests to check for browser support of modern CSS and HTML implementations like CSS 3d Transforms, HTML5 Video or Touch Events among &lt;a href=&quot;http://modernizr.com/download/&quot;&gt;many many others&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once it has checked for the features we intend to use, Modernizr appends classes to the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag. We can then provide a set of CSS rules to browsers that support those features and another set of fallback rules to browsers that don&amp;#8217;t support them.&lt;/p&gt;

&lt;p&gt;I created a Sass mixin that helps us write those rules in a &lt;em&gt;DRYer&lt;/em&gt; and more comprehensive way, reducing the amount of code needed and making it less error-prone and far easier to read and maintain.&lt;/p&gt;

&lt;p&gt;Before jumping into the code for the actual mixin, let&amp;#8217;s see how we actually write Modernizr tests in plain CSS.&lt;/p&gt;

&lt;h2&gt;Plain CSS&lt;/h2&gt;

&lt;p&gt;This is how we can write a rule-set to add a CSS3 gradient background:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.cssgradients .my-selector {
  background-image: linear-gradient(to bottom, #fff, #000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For browsers that don&amp;#8217;t support CSS gradients or for those where Javascript is not available or disabled and thus we can&amp;#8217;t test for support, we will need a fallback rule-set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.no-js .my-selector,
.no-cssgradients .my-selector {
  background-image: url('gradient.png');
  background-repeat: repeat-x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Making it Sassier&lt;/h2&gt;

&lt;p&gt;Sass allows selectors and rules to be &lt;a href=&quot;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#nested_rules&quot;&gt;nested&lt;/a&gt; so we can make that code prettier and much more organized, avoiding repetition of the selector:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.my-selector {
  .cssgradients &amp;amp; {
    background-image: linear-gradient(to bottom, #fff, #000);   
  }
        
  .no-js &amp;amp;,
  .no-cssgradients &amp;amp; {
    background-image: url('gradient.png');
    background-repeat: repeat-x;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Even better with a mixin&lt;/h2&gt;

&lt;blockquote class=&quot;pull-quote--right&quot;&gt;Easy? Yep and Nope.&lt;/blockquote&gt;

&lt;p&gt;Having written a lot of selectors and rules like the above, I got a bit tired of that code. It&amp;#8217;s not a complicated code at all, but it&amp;#8217;s a bit messy, it isn&amp;#8217;t that easy to read and maintain and I tend to forget to add the &lt;code&gt;.no-js &amp;amp;&lt;/code&gt; bit. So I thought a couple of mixins would do the job.&lt;/p&gt;

&lt;p&gt;One mixin would write the rule-set for available features. I called it &lt;code&gt;yep&lt;/code&gt;. The other one, &lt;code&gt;nope&lt;/code&gt;, would add the fallback rule-set. We use them like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.my-selector {
  @include yep(cssgradients) {
    // ...
  }
        
  @include nope(cssgradients) {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s extremely easy, I thought. This is all the code we actually need to make those two mixins work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin yep($feature) {
  .#{$feature} &amp;amp; { 
    @content;
  }
}
    
@mixin nope($feature) {
  .no-js &amp;amp;,
  .no-#{$feature} &amp;amp; {
    @content;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Multiple features at once&lt;/h2&gt;

&lt;p&gt;Ouch! What if we need to test for multiple features at the same time? &lt;/p&gt;

&lt;p&gt;It isn&amp;#8217;t as straightforward as I first thought. The &lt;code&gt;yep&lt;/code&gt; mixin should not produce the same kind of selectors as the &lt;code&gt;nope&lt;/code&gt; mixin. Take this example: we want to test for &lt;code&gt;csstransforms&lt;/code&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;code&gt;opacity&lt;/code&gt; and declare a specific rule-set. But if one of those features isn&amp;#8217;t supported, we need to fall back on another rule-set.&lt;/p&gt;

&lt;p&gt;This is the compiled CSS we are looking for:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.csstransforms.opacity .my-selector {
  // ...
}
    
.no-js .my-selector,
.no-csstransforms .my-selector,
.no-opacity .my-selector {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing I strived for was to keep the code as DRY as possible using some of the newness in Sass 3.3. As I worked through the logic I found that a single mixin could handle both cases.&lt;/p&gt;

&lt;h2&gt;Aliases&lt;/h2&gt;

&lt;p&gt;I created a main &lt;code&gt;modernizr&lt;/code&gt; mixin to handle both situations. You won&amp;#8217;t use it directly on your Sass stylesheet, but it&amp;#8217;s used internally by &lt;code&gt;yep&lt;/code&gt; and &lt;code&gt;nope&lt;/code&gt;.  In fact, &lt;code&gt;yep&lt;/code&gt; and &lt;code&gt;nope&lt;/code&gt;  are merely aliases of this more complex mixin. They only do one thing: call the &lt;code&gt;modernizr&lt;/code&gt; mixin with the set of features you&amp;#8217;re passing, and set a &lt;code&gt;$supports&lt;/code&gt; variable you won&amp;#8217;t need to remember. &lt;/p&gt;

&lt;p&gt;That&amp;#8217;s it, they&amp;#8217;re meant to be easier to remember because they require only one parameter: &lt;code&gt;$features...&lt;/code&gt;, faster to write because they are shorter and make the whole thing extremely easy to read because you instantly know what the intention of the code is.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// `yep` is an alias for modernizr($features, $supports: true)
@mixin yep($features...) {
  @include modernizr($features, $supports: true) {
    @content;
  }
}

// `nope` is an alias for modernizr($features, $supports: false)
@mixin nope($features...) {
  @include modernizr($features, $supports: false) {
    @content;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;The ultimate mixin&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;modernizr&lt;/code&gt; mixin expects two arguments: &lt;code&gt;$features&lt;/code&gt; which is our &lt;code&gt;argList&lt;/code&gt;, a comma-separated list of features and &lt;code&gt;$supports&lt;/code&gt;, a boolean which will be used to output the yep or the nope rules.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin modernizr($features, $supports) {
  // Sass magic
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside the mixin I set three variables to handle everything we need to generate.&lt;/p&gt;

&lt;h3&gt;The prefix&lt;/h3&gt;

&lt;p&gt;We need to use the &lt;code&gt;no-&lt;/code&gt; prefix if checking for unsupported features (e.g. &lt;code&gt;.no-opacity&lt;/code&gt;). If checking for supported features we need no prefix at all so we&amp;#8217;ll use an empty string in this case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$prefix: if($supports, '', 'no-');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The selector&lt;/h3&gt;

&lt;p&gt;To generate our feature selector (e.g. &lt;code&gt;.opacity.csstransforms&lt;/code&gt; or &lt;code&gt;.no-opacity, .no-csstransforms&lt;/code&gt;), we need two different strategies. We have to create a string if checking for supported features and we&amp;#8217;ll concatenate the class names later on. Or create a list if checking for unsupported features. We&amp;#8217;ll append class names later on too.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$selector: if($supports, '', unquote('.no-js'));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The placeholder&lt;/h3&gt;

&lt;p&gt;You&amp;#8217;ll see that all the magic that handles this thing is done by a placeholder. We&amp;#8217;ll need to give it a name that will look something like &lt;code&gt;%yep-feature&lt;/code&gt; or &lt;code&gt;%nope-feature&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$placeholder: if($supports, '%yep', '%nope');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Error handling&lt;/h3&gt;

&lt;p&gt;I also set a variable &lt;code&gt;$everything-okay: true&lt;/code&gt; which is meant for error handling. More on this later on.&lt;/p&gt;

&lt;h3&gt;Generating the placeholder and selectors&lt;/h3&gt;

&lt;p&gt;Now it&amp;#8217;s time to create our feature selectors and our placeholder names. We&amp;#8217;ll loop through the passed &lt;code&gt;$features&lt;/code&gt; to do so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@each $feature in $features {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within that loop we just need three lines of code. They&amp;#8217;re a bit heavy, but what they accomplish is quite simple:&lt;/p&gt;

&lt;h3&gt;Generate our placeholder name&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$placeholder: $placeholder + '-' + $feature;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting &lt;code&gt;$placeholder&lt;/code&gt; variables will look something like &lt;code&gt;%yep-opacity-csstransforms&lt;/code&gt; or &lt;code&gt;%nope-opacity-csstransforms&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Generate our selector name&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$new-selector: #{'.' + $prefix + $feature};
$selector: if($supports, $selector + $new-selector, append($selector, $new-selector, comma));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$new-selector&lt;/code&gt; will look something like &lt;code&gt;.csstransforms&lt;/code&gt; or &lt;code&gt;.no-csstransforms&lt;/code&gt;. We then concatenate &lt;code&gt;$new-selector&lt;/code&gt; or append it to the list (e.g. &lt;code&gt;.opacity.csstransforms&lt;/code&gt; or &lt;code&gt;.no-opacity, .no-csstransforms&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s it for generating our placeholder and selector names. Take the &lt;code&gt;opacity&lt;/code&gt; and &lt;code&gt;csstransforms&lt;/code&gt; example. This is the result of using &lt;code&gt;@include yep(opacity, csstransforms)&lt;/code&gt;;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@debug $placeholder; // %yep-opacity-csstransforms
@debug $selector; // .opacity.csstransforms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this the result of using &lt;code&gt;@include nope(opacity, csstransforms)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@debug $placeholder; // %nope-opacity-csstransforms
@debug $selector; // .no-js, .no-opacity, .no-csstransforms
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The placeholder and @content&lt;/h3&gt;

&lt;p&gt;It&amp;#8217;s time to write our placeholder. We use &lt;a href=&quot;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#interpolation_&quot;&gt;Sass interpolation&lt;/a&gt; to write the name we&amp;#8217;ve generated within the loop and then print the declaration block (&lt;code&gt;@content&lt;/code&gt;) we&amp;#8217;ve passed within the &lt;code&gt;yep&lt;/code&gt; or &lt;code&gt;nope&lt;/code&gt; mixin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;#{$placeholder} &amp;amp; {
  @content;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Extending with @at-root&lt;/h3&gt;

&lt;p&gt;Now we&amp;#8217;ll print our features &lt;code&gt;$selector&lt;/code&gt;(s) and extend the placeholder. But, there&amp;#8217;s a little problem here, if we extend the placeholder as-is: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;#{$selector} {
  @extend #{$placeholder}; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we&amp;#8217;ll get an unexpected CSS output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;.my-selector .opacity.csstransforms .my-selector { 
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need something to fix this. Sass 3.3&amp;#8217;s @at-root directive comes to the rescue:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@at-root #{$selector} {
  @extend #{$placeholder};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our features selector isn&amp;#8217;t placed  before the actual selector because &lt;code&gt;@at-root&lt;/code&gt; cancels the selector nesting.&lt;/p&gt;

&lt;h2&gt;Error handling&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@if type-of($feature) != &quot;string&quot; {
  $everything-okay: false;
  @warn '`#{$feature}` is not a string for `modernizr`';
} @else {
  // proceed ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within the previous loop we&amp;#8217;ll also check if every &lt;code&gt;$feature&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;. As Hugo Giraudel explains in his &lt;a href=&quot;http://webdesign.tutsplus.com/tutorials/an-introduction-to-error-handling-in-sass--cms-19996&quot;&gt;introduction to error handling in Sass&lt;/a&gt; we shouldn&amp;#8217;t let the Sass compiler fail and punch us in the face with an error. That&amp;#8217;s why we should prevent things like &lt;code&gt;10px&lt;/code&gt; or even nested lists like &lt;code&gt;(opacity csstransforms), hsla&lt;/code&gt;  to stop our stylesheet from successfully compiling.&lt;/p&gt;

&lt;p&gt;If a wrong parameter is passed, the compilation won&amp;#8217;t fail, but nothing will be generated and you&amp;#8217;ll be warned of the problem. &lt;/p&gt;

&lt;p&gt;If &lt;code&gt;$everything-okay&lt;/code&gt; is still &lt;code&gt;true&lt;/code&gt; after we iterate through the list of features, we&amp;#8217;re ready to generate the output code.&lt;/p&gt;

&lt;h2&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;It all started as a small Sass experiment and ended up being an incredibly interesting challenge. I came up with a piece of code that I never thought would make me push the Sass syntax as far as I did. It was really interesting to develop a solution that uses so many different Sass features like the &lt;code&gt;@at-root&lt;/code&gt; directive, loops (&lt;code&gt;@each&lt;/code&gt;), the ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;) to reference parent selectors, the &lt;code&gt;if()&lt;/code&gt; function, placeholders, list manipulation, … and also stuff like mixin aliases and error handling.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s it, you can play with the code on &lt;a href=&quot;http://sassmeister.com/gist/10578910&quot;&gt;SassMeister&lt;/a&gt; or &lt;a href=&quot;https://github.com/danielguillan/modernizr-mixin&quot;&gt;view the documentation and download on Github&lt;/a&gt;. The Modernizr mixin is available as a &lt;a href=&quot;http://rubygems.org/gems/modernizr-mixin&quot;&gt;Compass extension&lt;/a&gt; too.&lt;/p&gt;

&lt;p class=&quot;sassmeister&quot; data-gist-id=&quot;10578910&quot; data-height=&quot;480&quot;&gt;&lt;a href=&quot;http://sassmeister.com/gist/10578910&quot;&gt;Play with this gist on SassMeister.&lt;/a&gt;&lt;/p&gt;
&lt;script src=&quot;http://static.sassmeister.com/js/embed.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;http://cdn.shopify.com/s/files/1/0240/0941/t/4/assets/daniel-guillan-cdo.jpg?16714&quot; alt=&quot;Daniel Guillan&quot; /&gt; Daniel Guillan is the co-founder and chief design officer at Vintisis. Not only designer but also front-end developer, Daniel likes using Sass to make his life easier. You should catch him on &lt;a href=&quot;https://twitter.com/danielguillan&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
</item>

<item>
	<title>Sass mixins to kickstart your project</title>
	
	<link>http://www.sitepoint.com/sass-mixins-kickstart-project/</link>
	<guid>http://www.sitepoint.com/sass-mixins-kickstart-project/</guid>
	
	
	<pubDate>Thu, 08 May 2014 00:00:00 GMT</pubDate>
	<description>
</description>
</item>

<item>
	<title>Bringing configuration objects to Sass</title>
	
	<link>http://hugogiraudel.com/article/2014-05-05-bringing-configuration-objects-to-sass</link>
	<guid>/article/2014-05-05-bringing-configuration-objects-to-sass</guid>
	
	
	<pubDate>Mon, 05 May 2014 00:00:00 GMT</pubDate>
	<description>
&lt;p&gt;One thing I was really looking forward with &lt;a href=&quot;http://viget.com/extend/sass-maps-are-awesome&quot;&gt;Sass maps&lt;/a&gt; is the ability to have configuration objects for functions and mixins. You know how you pass objects to your JavaScript class constructors instead of several parameters? Well fasten your belt boys because I&amp;#8217;m bringing this to Sass!&lt;/p&gt;

&lt;h2&gt;An insight in the JS way of doing&lt;/h2&gt;

&lt;p&gt;Before digging into Sass awesomeness, let&amp;#8217;s first have a look at how we would do it in JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var Class = function (conf) {
  this.conf = extend({
    duration: 2000,
    name: 'class',
    theme: 'dark',
    speed: 500
  }, conf || {});

  this.init();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what&amp;#8217;s going on here? The &lt;code&gt;Class&lt;/code&gt; constructor is accepting a &lt;code&gt;conf&lt;/code&gt; parameter. Then it defines its own &lt;code&gt;conf&lt;/code&gt; property by merging the given object with a default configuration via the &lt;code&gt;extend&lt;/code&gt; function. If &lt;code&gt;conf&lt;/code&gt; isn&amp;#8217;t defined, then it extends an empty object with default properties.&lt;/p&gt;

&lt;p&gt;Extending an object based on another one is very convenient when you want to allow the user to define his own configuration but still want to provide defaults in case he doesn&amp;#8217;t set all arguments.&lt;/p&gt;

&lt;h2&gt;What&amp;#8217;s wrong with several parameters?&lt;/h2&gt;

&lt;p&gt;One could ask what is wrong with having several arguments in the signature with a default value for each of them. Tl;dr version is that using an object is just easier and more convenient. Now if you want the detail, here are the reasons behind why an object as unique parameter instead of several parameters sounds better.&lt;/p&gt;

&lt;h3&gt;Harder to read&lt;/h3&gt;

&lt;p&gt;To begin with, using an object makes it easier to understand since you have to specify the key associated to each value. While slightly longer to write, it&amp;#8217;s easier to read; a fair trade-off in my opinion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// This...
f({
  message: 'You shall not pass!',
  close: false,
  error: 42,
  type: 'error'
});

// ... is easier to understand than this
f('You shall not pass!', false, 42, 'error');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the readibility argument is kind of a poor one. Some would say that they feel very comfortable with the multiple-arguments notation as long as they use a proper indentation for each argument (kind of like the object one) so let&amp;#8217;s move on to something more robust.&lt;/p&gt;

&lt;h3&gt;Harder to call&lt;/h3&gt;

&lt;p&gt;It&amp;#8217;s generally simpler to store an object in a variable and then to pass it to the function rather than storing each individual parameter in its own variable. While &lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.apply()&lt;/code&gt; let you do something around this, it&amp;#8217;s not exquisite for readability (again!).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// This...
var conf = {
  message: 'You shall not pass!',
  close: false,
  error: 42,
  type: 'error'
};

f(conf);

// ... is easier to read than this
var conf = ['You shall not pass!', false, 42, 'error'];

f.apply(void 0, conf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still not convince? Let&amp;#8217;s move on.&lt;/p&gt;

&lt;h3&gt;Harder to maintain&lt;/h3&gt;

&lt;p&gt;Adding or removing is as easy as updating the configuration object. No need to update all the calls or change arguments order if some of theme are optional. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Adding a parameter is simple; no need to worry about argument order
f({
  message: 'You shall not pass!',
  close: false,
  error: 42,
  type: 'error',
  duration: 5000
});

// ... while you have to put your required parameters before optional one in the signature
f('You shall not pass!', 42, false, 5000, 'error');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Harder to provide default parameters&lt;/h3&gt;

&lt;p&gt;Last but not least, I think an object notation makes it simpler to provide defaults arguments with an &lt;code&gt;extend&lt;/code&gt; function than the multiple-arguments notation since JavaScript doesn&amp;#8217;t support default values for arguments in the function signature (while PHP, Sass and other languages do). Because of this, using an object is definitely more elegant than multiplying ternary operators to check if arguments are defined or not.&lt;/p&gt;

&lt;p&gt;I think we can agree on the fact that using a configuration object as a unique parameter is both better and more elegant than using a bunch of chained arguments. Now let&amp;#8217;s move on to the core of this article: bringing this to Sass.&lt;/p&gt;

&lt;h2&gt;Bringing it to Sass&lt;/h2&gt;

&lt;p&gt;In a way, we don&amp;#8217;t really need this in Sass because it already provides &lt;em&gt;named arguments&lt;/em&gt;. &lt;a href=&quot;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#keyword_arguments&quot;&gt;Named arguments&lt;/a&gt; give the ability to call a function without having to specify all its parameters. You can call it specifying only the arguments you want, no matter their index in the parameter list, like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin mixin($a: &quot;a&quot;, $b: &quot;b&quot;, $c: &quot;c&quot;) {
  /* ... */
}

@include mixin($b: &quot;boat&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty neat. But if like me you&amp;#8217;d rather have a single object instead of a collection of arguments, then read on. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Being able to use configuration objects in Sass is amazing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sass 3.3 is bringing maps which are the exact equivalent of JavaScript objects. Now that we have maps, we can do all the cool stuff we just talked about and &lt;strong&gt;this is amazing&lt;/strong&gt;. All we need is an &lt;code&gt;extend&lt;/code&gt; function to be able to extend a given object with an object of default parameters. &lt;/p&gt;

&lt;p&gt;This could have been very easy to do but &lt;code&gt;map-merge&lt;/code&gt; already does it for us. Indeed, when merging two maps it does exactly what we want: extend one map with the other. At best, we could alias the &lt;code&gt;map-merge&lt;/code&gt; function with an &lt;code&gt;extend&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@function extend($obj, $ext-obj) {
  @return map-merge($obj, $ext-obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So here it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$default-object: (
  dont: you think,
  this: is awesome
);

$object: (
  this: is amazing
);

$merge: extend($default-object, $object); 

/**
 * This results in
$merge: (
  dont: you think,
  this: is amazing
);
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Using it for real&lt;/h2&gt;

&lt;p&gt;Now what&amp;#8217;s the point of all of this? Let&amp;#8217;s say you have a component you call with a mixin. This mixin accepts quite a few parameters like &amp;mdash; I don&amp;#8217;t know &amp;mdash; the width, the color scheme, the animation duration, maybe a name or something. They probably have some default values defined to match a common use case. Until now, you have done it like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin component($theme: light, $size: 100%, $duration: 250ms, $name: 'component', $border: true) {
  .#{$name} {
    width: $size;
    animation: fade $duration;

    @if $border {
      border-top: .25em solid;
    }

    @if $theme == &quot;dark&quot; {
      background: #333;
      color: #FEFEFE;
    }
    @else if $theme == &quot;light&quot; {
      background: #FEFEFE;
      color: #333;
    }
  }
}

// Including component
@include component(dark, $name: 'module');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works great. It is easily readable, it does the job very well. However there is &lt;em&gt;one&lt;/em&gt; thing that still sucks with this method: you can&amp;#8217;t move the configuration elsewhere. Actually you can, but it will be like 5 variables which is getting a lot. Having a configuration map would be easier to move in a variable file or something.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin component($conf: ()) {
  // Extending the default arguments with the given object
  $conf: extend((
    size: 100%,
    theme: dark,
    duration: 250ms,
    name: 'component',
    border: true
  ), $conf);

  // Dumping CSS
  .#{map-get($conf, name)} {
    width: map-get($conf, size);
    animation: fade map-get($conf, duration);

    $theme: map-get($conf, theme);
    @if $theme == &quot;dark&quot; {
      background: #333;
      color: #FEFEFE;
    }
    @else if $theme == &quot;light&quot; {
      background: #FEFEFE;
      color: #333;
    }
  }
}

// Including component
@include component((
  theme: dark, 
  name: 'module'
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both doesn&amp;#8217;t look much different except the core function from the object-way looks more crowded. True, but now separating the setup from the code is getting very easy. All you have to do is defining a map and pass it to the mixin. No need to move around a couple of variables which can quickly become a mess.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;// In `_config.scss` along with your other setup variables
$component-conf: (
  theme: light,
  name: 'module',
);

// In `_component.scss`
@include component($component-conf);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;There you go folks. This is definitely a more &amp;#8220;Object&amp;#8221; approach than the previous one and I can understand some people not liking it because it doesn&amp;#8217;t look like we are dealing with CSS anymore. &lt;/p&gt;

&lt;p&gt;Now if you ask me, not only does it make both the mixin signature cleaner, but it also gives you more flexibility about your code structure and &lt;em&gt;this&lt;/em&gt; is a big deal when working on a huge project with countless components. Being able to gather configuration maps in a variables file can make a huge difference when it comes to code maintenance.&lt;/p&gt;

&lt;p&gt;And while the mixin core is a little more crowded due to the map getters, the trade-off can be worth it in some cases.&lt;/p&gt;
</description>
</item>

<item>
	<title>What’s the difference between Sass and SCSS?</title>
	
	<link>http://www.sitepoint.com/whats-difference-sass-scss/</link>
	<guid>http://www.sitepoint.com/whats-difference-sass-scss/</guid>
	
	
	<pubDate>Tue, 29 Apr 2014 00:00:00 GMT</pubDate>
	<description>
</description>
</item>

<item>
	<title>Casting a map into a list in Sass</title>
	
	<link>http://hugogiraudel.com/article/2014-04-28-casting-map-into-list</link>
	<guid>/article/2014-04-28-casting-map-into-list</guid>
	
	
	<pubDate>Mon, 28 Apr 2014 00:00:00 GMT</pubDate>
	<description>
&lt;p&gt;I have this article ready for about 3 months now but I never found an occasion to release it&amp;#8230; until today! This will be quite short but I still wanted to write a little something on the topic anyway. You might have read my &lt;a href=&quot;http://hugogiraudel.com/2014/01/27/casting-types-in-sass/&quot;&gt;article about SassyCast&lt;/a&gt;, a small Compass extension I wrote to convert data types in Sass.&lt;/p&gt;

&lt;p&gt;SassyCast making possible to go from any data type to any data type (or almost), it includes a way to cast a map into a list. While the function I wrote was kind of straight forward, &lt;a href=&quot;https://twitter.com/JulienCabanes/status/427920448899538944&quot;&gt;Julien Cabanes showed me a cool little improvement to the function&lt;/a&gt; on Twitter. I merged his code in SassyCast 1.0.0.&lt;/p&gt;

&lt;h2&gt;The old way&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;to-list&lt;/code&gt; function core is pretty straightforward. If the given value is a map, we iterate over it to create a 2-dimensional list like this: &lt;code&gt;( &quot;key-1&quot; &quot;value 1&quot;, &quot;key-2&quot; &quot;value 20&quot; )&lt;/code&gt;. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@function to-list($value) { 
  @if type-of($value) == map {
    $keys: ();
    $values: ();
    @each $key, $val in $value {
      $keys: append($keys, $key);
      $values: append($values, $val);
    }
     @return zip($keys, $values);
  }

  @return if(type-of($value) != list, ($value,), $value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To be a little more precise about what&amp;#8217;s being done here: we loop through each map entry, store the key in a &lt;code&gt;$keys&lt;/code&gt; list and the value in a &lt;code&gt;$values&lt;/code&gt; list. Then we &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Script/Functions.html#zip-instance_method&quot;&gt;zip&lt;/a&gt; both to return a 2-dimensional list where the first element of each list if the former key and the second element of each list is the former value.&lt;/p&gt;

&lt;p&gt;Does the job well.&lt;/p&gt;

&lt;h2&gt;The new way&lt;/h2&gt;

&lt;p&gt;Julien thought it would be cool to be able to keep only keys, or only values or both (what I&amp;#8217;ve done) so he added an extra parameter to the function accepting either &lt;code&gt;keys&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; or &lt;code&gt;both&lt;/code&gt;. Every other value would fallback to &lt;code&gt;both&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then depending on the flag, he returns either &lt;code&gt;$keys&lt;/code&gt; or &lt;code&gt;$values&lt;/code&gt; or a zip of both.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@function to-list($value, $keep: 'both') {
  $keep: if(index('keys' 'values', $keep), $keep, 'both');
  
  @if type-of($value) == map {
    $keys: ();
    $values: ();
    @each $key, $val in $value {
      $keys: append($keys, $key);
      $values: append($values, $val);
    }

    @if $keep == 'keys' {
      @return $keys;
    }
    @else if $keep == 'values' {
      @return $values;
    }
    @else {
      @return zip($keys, $values);
    }
  }

  @return if(type-of($value) != list, ($value,), $value);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;#8217;t like conditional return statements or if you simply want to look like a badass with an unreadable ternary mess, you could return something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@return if($keep == 'keys', $keys, if($keep == 'values', $values, zip($keys, $values)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Literally:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If &lt;code&gt;$keep&lt;/code&gt; is &lt;code&gt;'keys'&lt;/code&gt;, return &lt;code&gt;$keys&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Else if &lt;code&gt;$keep&lt;/code&gt; is &lt;code&gt;'values'&lt;/code&gt;, return &lt;code&gt;$values&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Else return &lt;code&gt;zip($keys, $values)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;Let&amp;#8217;s try it with a little example, shall we? First, our map.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$breakpoints: (
  small: 600px,
  medium: 900px,
  large: 1200px
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, we cast it to a list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$breakpoints-list: to-list($breakpoints, 'both');
// (small 600px, medium 900px, large 1200px)

$breakpoints-keys: to-list($breakpoints, 'keys');
// (small medium large)

$breakpoints-values: to-list($breakpoints, 'values');
// (600px 900px 1200px)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s all folks! Thanks again Julien!&lt;/p&gt;

</description>
</item>

<item>
	<title>My favourite Sass tools</title>
	
	<link>http://www.sitepoint.com/my-favorite-sass-tools/</link>
	<guid>http://www.sitepoint.com/my-favorite-sass-tools/</guid>
	
	
	<pubDate>Wed, 23 Apr 2014 00:00:00 GMT</pubDate>
	<description>
</description>
</item>

		
	</channel>
</rss>